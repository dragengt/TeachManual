#Chapter5. 循环：计数器下的一百次连击

##1. 说说“当”

在开始我们的“正业”——打击勇者之前，让我们先来唱一首家喻户晓的歌：

>当山峰没有棱角的时候……
当河水不再流……
……
然后怎么样怎么样。

其实，“当……”就蕴含着一个朴素的思想：

> 当 （条件满足的时候）
那么--> 做点什么

就比如说：只要音乐还在播放，小明就跳舞。

这就是循环的意思：当音乐还在继续，小明就不断地执行“跳舞”这个动作。

> ![Let us dance](srcImg/danceDog.gif do it) "耶，Let's dance~这就是循环"

当然，细想一下，歌词里的“当”更应该是表达了“即使……也……”的意思，而不应该是我们这里的“当……就……”，不然的话，歌词就变味了。之所以会衍生出这么多的意思，大概是因为中文实在是博大精深。

所以，需要提前声明一下，下面开始描述的“while”，应该是“当……就……”的意思。

##2. 当、当、当……while循坏

回到我们的正题上：如何重复地打击勇者，而不用手动复制几十次的TakeDamage（）调用。

要实现这个目标，我们就要想清楚用于描述这个行为的过程，这样才能写出合理的语句让计算机听得懂。

一般地，我们会给出这么一段话，来描述我们打击勇者的过程：

```

1. 如果 （勇者还没Game Over），则：
{
	2. 打击勇者（）；
	3. 回到第1步；
}

4. 输出：游戏结束了~

```
按照这个流程而走，只要勇者还没死亡，那么程序就会不断地执行1、2、3步，然后又回到1、2、3步。

当然，只要勇者血量低于0了，那么第1步过后由于条件不满足，就会运行到第4步，也就是……游戏，结束了。

在早期的程序中，确实存在这么样的类似于if 和 goto的句法以实现循环的功能。但是，在js里面，这样的句法太过晦涩，而换用了“while”语句以实现我们的需求。while跟if的语句何其相似：

```js

while( 条件 )
{
	执行某些事情( );
}

```

这里的while，其实可以理解为“当条件满足时，那么就执行该部分内的语句，直到条件不再满足为止”。

所以，正题来了，只要hp大于0，那么，勇者就会遭受命运的摧残：


```js

var heroHP = 100;
while( heroHP > 0)
{
	heroHP = heroHP - 10;
	console.log(  "一天过去，勇者失去了10点生命值……剩下HP: "+heroHP  );
}

console.log( " 游戏……结束了。 ");

```

在上面的代码中，可以很容易理解while循环：当勇者的血量大于0的时候，那么他会度过一天，并失去10点生命值，直到10天后他的血量终于变成了0，自此while循环的条件不再被满足，循环不会被执行，所以会执行while后面的一句，游戏结束。

实际上，while就是游戏程序，甚至是任一软件背后的主体部分，比如游戏中通常会有这么样的代码结构：

```
某些数据的初始化，如游戏状态等；
装载内容；

while( 游戏还没结束)
{
	获取用户输入；
	处理游戏角色，处理对应的许多事件；
}

输出游戏结束；
清理数据；

```

同理，在软件中，则是：
```
程序初始化，如连接网络、读取文件；

while( 程序状态正常 )
{
	获取输入，比如鼠标点击事件；
	处理事件；
}

清理数据，断开网络等，程序退出；

```

话说回来，现在我们已经知道了如何实现“当勇者还活着的时候，不断地打击勇者”，那么，假如我们突然“心慈手软”，只想打击勇者10次，每次都调用之前的TakeDamage( )，看看勇者有没有可能活下来，怎么办？

其实很好解决这一类“循环N次”的问题，只要一个能记住次数的变量即可，而while里面的条件自然是当计数器counter 小于等于10时执行循环体：

```js
//先声明TakeDamage，勇者的HP：
var heroHP = 100;
function TakeDamage( )
{
	//同之前，略
}

//声明一个在一边计数的变量，注意一定是在while外面声明，而不是在while里面声明，为什么？
var counter = 1;

//当计数器<=10时，即说明还没攻击完勇者。
while( counter <= 10)
{
	//输出对勇者的打击：
	console.log("第"+counter+"次打击勇者，勇者掉血！");

	//勇者受伤：
	TakeDamage( );


	//计数器加1：
	counter ++;
}

console.log("好了……不虐勇者了，可以放他走了。");

```

其实……只要你细心，你就会发现上面的代码与持续不断杀死勇者的那段代码并没有本质上的区别：都是用一个变量去控制循环的次数。

事实上，很多代码都会用到这样的形式的循环：

```
1.初始语句：声明 计数器，以控制循环的次数；

2.循环条件：
while( 计数器达到某个条件 )
{
 	//执行代码；

 	3.每一轮循环完后的动作：
	计数器+1；
}

```

由于这样的情况满大街都会出现，所以，一种新的循环形式就应运而生了，我们可以将之称为——for循环。


##3. 你是谁，for了谁，我的兄弟for循环~


for循环是江湖上一个没什么神秘的“帮派”，如果说有，也就是要睁大眼睛注意for语句中的分号了：

```

for( 初始语句; 循环条件; 每一轮循环完成后的动作)		//注意哟，这里有两个分号
{
	//执行代码；
}

```

看出来了没，其实就是把三句最常用的话写到了for语句里，而且——划重点的地方来了——三条语句是用两个分号隔开的，因为这里是*三句话，三句话，真的是三句话*！这三句话支撑了循环界的半壁江山，而且作用还各不相同，让我们暂时撇开勇者，来看看“循环体”的世界：

 - 初始语句：这是for循环的带头大哥了，很多循环的初始条件，比如设置计数器为0，或者1，都会在这里声明，而且只会在for循环开始的时候*执行一次*，其实相当于把初始语句写在for语句前面——当然你非要这么做，那也是没人管你的。
 
 - 循环条件：这个就厉害了，每次循环开始前，都会检查一次循环条件，如果满足条件，则循环继续，否则，略过循环。
 
 - 每轮循环完成后动作：看看这位兄弟的名字就知道，他做的是每轮循环后的收尾工作，当然，如果你不喜欢它……那就……回去用你的while循环吧！

就此，我们对勇者进行十连击，也就是执行十次TakeDamage的话，会是怎么样的表述？首先一定要有个变量来计算次数，为了方便，我们用变量 i 好了：

```js

for( var i = 0; i< 10 ;i++)
{
	//简单起见这里直接输出了：
	console.log("第"+ i + "天到来了");
	console.log("啊……勇者受到了伤害！");
}

```

上面的代码你看出了什么不一样的地方了吗？对，那就是初始条件i=0。那么问题来了，循环条件处是i<10才执行循环内容，那么，此处的for循环会执行多少次？

答案是10次，i分别会是：0、1、2、3、4、5、6、7、8、9。注意，i=10的时候，是不满足i<10的，所以不会输出“第10天”的字样。然而i=9的时候……已经是第十天啦！

这里就涉及到一个经典笑话了：程序猿从0开始数起，而不是从1开始。比如桌上有三个苹果，程序猿会认为它们分别是：0号苹果、1号苹果、2号苹果。

那么，问题又来了：为什么从0数起？因为0本身就是一个数啊！换个角度想，假如给你一个位置，只准放一个数字，那么总共可以有多少种放置的方法？答案自然是可以分别放0~9，共计10种不同的数字。所以，你需要接受一个事实：0才是第一个数。（此处应该有旁白：当你接受了这个答案，你也就是一名合格的程序猿了。）

回到for循环上，如果我们想让勇者受到一百次连击……

> 勇者：停一下，停一下！为什么还要让我受到100连击！为什么不举个例子是我出去杀死了100只怪物？
> 旁白：年轻的勇者哟，100只怪物可都是生命哟，你还是接受这个现实吧，再吐槽就把你的血量直接置为50哟。
> 勇者：……呸！你们这里是黑心课堂，当我进错片场了！

##4. 勇者必须死：循环中断了

咳咳，回到for循环上，如果我们想让勇者受到一百次连击，你会怎么做？对，修改循环条件为100即可。

那么不如我们来演示一下吧，把TakeDamage加入我们的循环，会产生什么效果？

```js

//-------------------------------------------------------------------------
//	此部分与前面章节一致，允许你复制代码而不是重新敲一遍
//-------------------------------------------------------------------------

var heroHP = 100;

function TakeDamage()
{
	//将要被扣的血：这里限制在30以内的随机数
	var randHP = Math.round( Math.random() * 30 );
        
	console.log("呜……勇者受到"+randHP+"点伤害！");

	//扣血
	heroHP = heroHP - randHP;
	
	//看看勇者生命值是否为负值，是的话输出游戏结束
	if(heroHP <= 0)
	{
		console.log("游戏结束了！勇者已经死翘翘了！");
	}
	else
	{
		//--否则的话，输出目前的HP
		console.log("现在HP: "+heroHP);
	}
}

//-------------------------------------------------------------------------
//	下面请跟着敲一遍，相信我，新手不默默敲一遍，以后定会出错
//-------------------------------------------------------------------------

console.log("勇者的噩梦开始了……");

//循环100次打击勇者
for( var i = 0; i < 100 ; i++)
{
	//输出一些信息：
	console.log("----------------------------------------------------------");
	console.log("第"+i+"天到来了……");
	console.log("勇者走在路上。突然，一道闪电劈中了他！");

	TakeDamage( );

	console.log("勇者：...真是倒霉的一天。");
}

console.log("勇者的噩梦……总算是结束了。但是，他的一生也结束了。");

```

按照上述程序的逻辑，勇者会受到100次的无情雷劈，但是，问题又来了：当勇者已经被劈死的时候，为什么老天还要不断地对他进行鞭尸，而不是中断循环呢？

——于是，可以打断循环的语句“break”大哥出场了。

break听起来名字很酷，他的作用也很酷：如果执行了他，他就可以打断循环，直接跳出循环体，从而可以执行之后的语句。

比如以下一个不像循环的循环，将可以展示for循环的执行顺序的同时，还能展示break的作用：

```js
var i = 0 ;
for( alert("初始条件") ; alert("判断是否进入循环") , i < 10 ; alert("每次循环后的动作") )
{
	alert("啦啦啦，进入到循环了~~~");
	break;

	alert("囧~~~我想我这句话是没办法弹出来的了……");
}

console.log("0_0...…我，我是在循环……外面的语句啦");

```

猜一下，哪部分会执行，弹出什么内容？

答案是：分别弹出“初始条件”、“判断是否进入循环”、“啦啦啦，进入到循环了~~~”，没了。看出来了吧，这就是break的厉害之处：遇到break，循环就要乖乖退出，并且不会运行每轮循环结束后的语句。
好了，让我们来试试如何修改之前的代码，具有“判断勇者死活，如果勇者死了，就跳出循环”的功能。

>
<img src = "srcImg/shockCat.jpg"  width="80px" />Q：慢着，for循环里好像内容有点多啊！里面好像有很多句话？？？

>
<img src = "srcImg/coldFace.jpg"  width="80px" />A：我说什么来着……分号才是一句话的结束标志，记住了，逗号代表这句话还没说完呢。

>
<img src = "srcImg/shockCat.jpg"  width="80px" />Q：那，那逗号有什么其他作用吗？

>
<img src = "srcImg/coldFace.jpg"  width="80px" />A：当然有了，分隔不同的语句呗。而且，请记住，最后面的那句话可以有对应的结果，也就是说，整句话都会运行，但是如果需要这句话的最终值的话，会以最后那句为准——这就叫逗号表达式。

>
<img src = "srcImg/shockCat.jpg"  width="80px" />Q：？？？这么绕？最终值？什么来的？

>
<img src = "srcImg/coldFace.jpg"  width="80px" />A：举例而言，假如有 
```js
if( 1>10, 11 > 0 )  
	console.log("Yes.");
```
那么1>10虽然会执行一次判定，但是11>0也执行了一次判断，而且最终结果是11>0为准。

>
<img src = "srcImg/shockCat.jpg"  width="80px" />Q：似乎明白了，那逗号表达式其实不是这么用的吧？更大的用处应该是像之前那样，可以在一个小语句里运行两句的吧？

>
<img src = "srcImg/coldFace.jpg"  width="80px" />A：对。这里是演示for的流程顺序，让你确信我在之前说的for里面的执行流程而已。很少人会在一句话里嵌入太多的内容，毕竟不够简洁直观。

现在，回到正题：拒绝对勇者进行“鞭尸”。稍加改动，就可以避免了。当然，这次为了流程需要（判断勇者死否死亡的代码出现两次），将会把TakeDamage( )稍加改动。以此灌输一个编码原则：*同一段代码出现两次时，最好把它封装成一个方法*。**当然……实际上如果是一句话的代码就没什么必要了。**

```js

//-------------------------------------------------------------------------
//	此部分与前面章节大体上一致，允许你复制代码而不是重新敲一遍
//-------------------------------------------------------------------------

var heroHP = 100;

//判断勇者是否死亡的方法
function IsHeroDead( )
{
	return  heroHP <=0;
}

function TakeDamage( )
{
	//将要被扣的血：这里限制在30以内的随机数
	var randHP = Math.round( Math.random() * 30 );
        
	console.log("呜……勇者受到"+randHP+"点伤害！");

	//扣血
	heroHP = heroHP - randHP;
	
	//看看勇者是否没有死亡： IsHeroDead为假，也就是勇者还没有死亡
	if( IsHeroDead( ) == false )
	{
		//没死亡的话，输出目前的HP
		console.log("现在HP: "+heroHP);
	}
}

//-------------------------------------------------------------------------
//	下面请跟着敲一遍，好记性不如烂笔头，看代码不如敲代码
//-------------------------------------------------------------------------

console.log("勇者的噩梦开始了……");

//循环100次打击勇者
for( var i = 0; i < 100 ; i++)
{
	//输出一些信息：
	console.log("----------------------------------------------------------");
	console.log("第"+i+"天到来了……");
	console.log("勇者走在路上。突然，一道闪电劈中了他！");

	TakeDamage( );

	//判断勇者是否已经死亡
	if( IsHeroDead( ) )
	{
		console.log("旁白：呜呜呜……勇者死了，还以为可以对他连击100次的，谁想到……游戏提前结束了！");

		//--中断循环
		break;
	}
	else
	{
		console.log("勇者：...真是倒霉的一天。小日子继续~");
	}
}

console.log("勇者的噩梦……总算是结束了。但是，他的一生也结束了。大概卒于第" + i +"天");

```

运行起来的话……你就会发现，由于中断循环时，i保持着当初的值，所以还能看出勇者最终撑到了第几天：

![Hero……die again](srcImg/chapter5_heroDieInLoop.png 嗯……如你所愿又挂了)

---
**“做英雄，真累啊……”——勇者疲惫地倒下了。**

##5. 死循环：一个神奇的地方

什么是死循环？请看下一句。
……请参看上一句。

那么问题又来了——死循环会让电脑崩溃吗？答案是否定的，它只会让你的页面或者浏览器无响应，尽管事实上它并不是真的卡死了，而是在执行一些看似无止尽的运算。

如何判断一个程序是否进入了死循环？实际上电脑对这个问题是无解的。如果不信，请参看文末拓展阅读。那么怎么写出一个死循环呢？很简单，判断条件永远满足就行了，也就是恒为true的恒等式，比如：
```js
while( 1 >0 )
{
	console.lolg("我不建议你拿这个来刷屏");
}

//或者：
for(var i = 0 ; i < 10 ; ) 				//看到没，这也是个死循环，因为i一直是0
{
	console.log("这是个无意中写出来的死循环……'啊！我错在哪了？'");
}

```

甚至可以写成：
```js
while( true )
{
	console.log("哈哈哈，无限循环下去吧！");
}
```

##6. 扩展阅读——循环外传：那些重复做的事

嗯，循环是个好东西，能让你从重复行为中解脱出来。这里所说的重复行为，不仅仅是简简单单的扣血N次，还可以有很多的应用，比如……

###6.1. 升级之路：勇者的经验值

不管玩游戏，还是挂QQ，你都能发现，他们每级的经验值都是不一样的，而且是越到后面，数字越爆炸式地增长（当然了……不爆炸怎么让你投入更多的时间去玩）。我们的勇者也如此，他发现每隔一级，该等级所需要的经验值似乎是这样计算出来的：

> 经验值= 等级数的三次方+50

由于每到达一个等级，勇者的经验值就会被清零，当然，升到下一级所需要的经验值也会相应改变，那么，勇者很想知道，从1级慢慢打怪打起，直到90级，总共需要多少经验？

其实这还是个累加问题，只不过计算的时候稍加变化了些。

```js
//总共需要的经验值
var totalExp = 0;

//声明一个计算某一级对应的经验值的方法：
function NeedExpAt ( level )
{
	return Math.pow (level,3 ) + 50;		//Math.pow 是一个计算某个数的N次方的方法，这里对level开3次方
}

//让我们看看为了玩游戏会有多浪费生命吧：
for( var i = 0 ; i < 90 ; i++ )
{
	//别忘了等级要加1，因为我们习惯于i起始值为0：
	var level = i+ 1;

	//获得这一等级需要的经验值
	var exp = NeedExpAt( level );

	//加到总共经验值上
	totalExp = totalExp + exp ;
}

```
答案是多少来着？试试看呗。

###6.2. 又是泛滥的兔子怪们

还是那个问题，兔子数量按照1，1，2，3，5，8，13，21……的规律不断增长，那么请问在48个月后，兔子数目有几何？

在计算这样的问题的时候，我们只需要知道数字的规律，然后利用两个变量来记录前面的两个数字就够了。

具体而言，就是每次记录第一、第二个月的数目，然后即可求出第三个月的数目；
再往后，则可以通过第二、三个月的数目，求出第四个月的兔子数目，以此类推。其实这样想来，算法不同，似乎会带来效率上的不一样哟。现在尝试自己写写解答过程吧，下面给出具体的代码，当然，还有对应的思考题：

```js

//求出第m个月下的兔子数目：
function CountRabbitsAt ( month )
{
	var count_0 = 1;
	var count_1 = 1;
	var total     = 0;				//存储结果的变量：为什么要声明在这里而不是在循环里面？
	//前两个月直接返回，无需计算
	if ( month <=2 )
	{
		return 1;
	}
	
	//否则的话，让我们重复所述的过程吧：
	//这里需要注意【边界条件】，你会看到我们的i的初始值并不是0，因为我们的计算次数要多少次来着？
	for( var i =  2 ; i < month ; i++ ) 
	{
		//获得总数目：
		total = count_0 + count_1;
		
		//更新一下下一轮开始的计数：请思考为什么是这种顺序，能否对调？
		count_0 = count_1 ;
		count_1 = total;

	}

	//返回结果
	return total;
}

```
如果觉得程序有错，可以测试一下对应的结果，咱们先从最小的开始测起才能知道程序的正确性：

```js
CountRabbitsAt(1);

CountRabbitsAt(4);

CountRabbitsAt(8);

CountRabbitsAt(48);
```

而后，看看5年后，也就是60个月后是多少什么吧：
```js
CountRabbitsAt(48);
```

可以观察到控制台很快就能输出答案，是1,548,008,755,920只！一万亿只！这跟我们初次看到这个数列时候的直觉完全相违背。你会觉得数字的增长速度似乎并没有那么快啊……现在呢？

如果没有限定草原草地面积，没有天敌（勇者）伤害的情况下，兔子们将可以迅速占领地球，我们只能俯首称臣。还好勇者们与狼共舞，在大自然的生存法则之下将兔子的数量控制在了平衡的范围内，万幸。

关于求解的方式，与用递归求解的方法相比，你会发现同样的求第几个月后的数目，循环却能更快地算出结果。为什么？因为我们的循环并不需要不断地开辟新的“方法”占用新的内存空间，只要循环对应的次数就足够了。

然而，如果你尝试去算出递归的方法的次数的话，你会发现两种方式的计算次数也根本不是一个量级的。当然，不要责怪递归不好，递归其实是可以高效地给出答案的，只不过我们没好好处理它而已。这就好像拥有了一把锋利的菜刀，如果你用刀背来切菜的话，肯定会认为它“不好”。

###6.3. 关于字符串的“串”：简易的移位加密器



//--字符串：悄悄引入数组的概念先；


//TODO:
边界条件、